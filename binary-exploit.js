// Binary Exploit Game Logic

// Ambient sound using Web Audio API for seamless looping
let audioContext;
let ambientBuffer;
let ambientSource;
let gainNode;

async function loadAmbientSound() {
    try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        gainNode = audioContext.createGain();
        gainNode.gain.value = 0.3;
        gainNode.connect(audioContext.destination);
        const response = await fetch('sounds/crt-hum.mp3');
        const arrayBuffer = await response.arrayBuffer();
        ambientBuffer = await audioContext.decodeAudioData(arrayBuffer);
    } catch (error) {
        console.log('Could not load ambient sound:', error);
    }
}

function startAmbientSound() {
    if (!audioContext || !ambientBuffer) return;
    if (audioContext.state === 'suspended') audioContext.resume();
    if (ambientSource) return;
    ambientSource = audioContext.createBufferSource();
    ambientSource.buffer = ambientBuffer;
    ambientSource.loop = true;
    ambientSource.connect(gainNode);
    ambientSource.start(0);
}

// Difficulty configuration
const DIFFICULTY_CONFIG = {
    low: {
        gridSize: 7,
        timeLimit: 30,
        name: '7x7'
    },
    standard: {
        gridSize: 9,
        timeLimit: 40,
        name: '9x9'
    },
    high: {
        gridSize: 11,
        timeLimit: 50,
        name: '11x11'
    }
};

// Game state
let currentDifficulty = null;
let grid = [];
let sourcePos = null;
let destinationPos = null;
let timeRemaining = 0;
let timerInterval = null;
let gameRunning = false;

// DOM elements
const difficultyScreen = document.getElementById('difficulty-screen');
const gameScreen = document.getElementById('game-screen');
const resultsScreen = document.getElementById('results-screen');

const currentDifficultyDisplay = document.getElementById('current-difficulty');
const timerDisplay = document.getElementById('timer-display');
const pathStatus = document.getElementById('path-status');
const binaryGrid = document.getElementById('binary-grid');
const messageDisplay = document.getElementById('message-display');

const startBtn = document.getElementById('start-btn');
const restartBtn = document.getElementById('restart-btn');
const retryBtn = document.getElementById('retry-btn');
const menuBtn = document.getElementById('menu-btn');
const backBtn = document.getElementById('back-btn');

const resultsStatus = document.getElementById('results-status');
const resultsScore = document.getElementById('results-score');
const resultsMessage = document.getElementById('results-message');

// Initialize game
function init() {
    setupDifficultySelection();
    setupEventListeners();
}

// Setup difficulty selection
function setupDifficultySelection() {
    const difficultyOptions = document.querySelectorAll('.difficulty-option');

    difficultyOptions.forEach(option => {
        option.addEventListener('click', function() {
            const difficulty = this.getAttribute('data-difficulty');
            selectDifficulty(difficulty);
        });

        option.setAttribute('tabindex', '0');
        option.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                const difficulty = this.getAttribute('data-difficulty');
                selectDifficulty(difficulty);
            }
        });
    });
}

// Select difficulty
function selectDifficulty(difficulty) {
    currentDifficulty = DIFFICULTY_CONFIG[difficulty];

    // Update UI
    difficultyScreen.classList.remove('active');
    gameScreen.classList.add('active');

    // Update HUD
    currentDifficultyDisplay.textContent = currentDifficulty.name;
    timeRemaining = currentDifficulty.timeLimit;
    updateTimerDisplay();

    // Generate grid
    generateGrid();
}

// Generate random grid
function generateGrid() {
    const size = currentDifficulty.gridSize;
    grid = [];

    // Initialize grid with random true/false values
    for (let y = 0; y < size; y++) {
        grid[y] = [];
        for (let x = 0; x < size; x++) {
            grid[y][x] = Math.random() > 0.5;
        }
    }

    // Place source at top (random x position)
    const sourceX = Math.floor(Math.random() * size);
    sourcePos = { x: sourceX, y: 0 };

    // Place destination at bottom or side
    let destX, destY;
    if (Math.random() > 0.5) {
        // Bottom
        destX = Math.floor(Math.random() * size);
        destY = size - 1;
    } else {
        // Side
        destX = (Math.random() > 0.5) ? size - 1 : 0;
        destY = Math.floor(Math.random() * (size - 2)) + 1; // Not at corners
    }
    destinationPos = { x: destX, y: destY };

    // Render grid
    renderGrid();
    updatePathStatus();
}

// Render grid
function renderGrid() {
    binaryGrid.innerHTML = '';
    binaryGrid.className = `grid-${currentDifficulty.gridSize}`;

    const size = currentDifficulty.gridSize;

    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            const cell = document.createElement('div');
            cell.className = 'binary-cell';
            cell.dataset.x = x;
            cell.dataset.y = y;

            // Check if source or destination
            if (x === sourcePos.x && y === sourcePos.y) {
                cell.classList.add('source');
            } else if (x === destinationPos.x && y === destinationPos.y) {
                cell.classList.add('destination');
            } else {
                // Add click handler
                cell.addEventListener('click', () => toggleCell(x, y));

                // Set initial state
                if (grid[y][x]) {
                    cell.classList.add('active');
                }
            }

            binaryGrid.appendChild(cell);
        }
    }
}

// Toggle cell state
function toggleCell(x, y) {
    if (!gameRunning) return;

    grid[y][x] = !grid[y][x];

    // Update visual
    const cell = binaryGrid.querySelector(`[data-x="${x}"][data-y="${y}"]`);
    if (grid[y][x]) {
        cell.classList.add('active');
    } else {
        cell.classList.remove('active');
    }

    // Check path
    updatePathStatus();
}

// Update path status
function updatePathStatus() {
    // Clear previous path visualization
    document.querySelectorAll('.binary-cell').forEach(cell => {
        cell.classList.remove('path', 'stalled');
    });

    // Check if path exists
    const pathResult = findPath();

    if (pathResult.found) {
        // Check for branching/stalls
        const hasBranching = checkForBranching(pathResult.path);

        if (hasBranching) {
            pathStatus.textContent = 'BRANCHING DETECTED';
            pathStatus.className = 'hud-value stalled';

            // Highlight stalled cells
            highlightStalledCells(pathResult.path);
        } else {
            pathStatus.textContent = 'VALID PATH';
            pathStatus.className = 'hud-value valid';

            // Highlight path
            pathResult.path.forEach(pos => {
                const cell = binaryGrid.querySelector(`[data-x="${pos.x}"][data-y="${pos.y}"]`);
                if (cell && !cell.classList.contains('source') && !cell.classList.contains('destination')) {
                    cell.classList.add('path');
                }
            });

            // Check for win
            if (gameRunning) {
                winGame();
            }
        }
    } else {
        pathStatus.textContent = 'NO PATH';
        pathStatus.className = 'hud-value invalid';
    }
}

// Find path from source to destination using BFS
function findPath() {
    const size = currentDifficulty.gridSize;
    const visited = new Set();
    const queue = [];
    const parent = new Map();

    // Start from source
    const startKey = `${sourcePos.x},${sourcePos.y}`;
    queue.push(sourcePos);
    visited.add(startKey);
    parent.set(startKey, null);

    const directions = [
        { dx: 0, dy: -1 }, // up
        { dx: 1, dy: 0 },  // right
        { dx: 0, dy: 1 },  // down
        { dx: -1, dy: 0 }  // left
    ];

    while (queue.length > 0) {
        const current = queue.shift();

        // Check if reached destination
        if (current.x === destinationPos.x && current.y === destinationPos.y) {
            // Reconstruct path
            const path = [];
            let node = current;
            const nodeKey = `${node.x},${node.y}`;

            while (node) {
                path.unshift(node);
                const key = `${node.x},${node.y}`;
                const parentKey = parent.get(key);
                if (!parentKey) break;
                const [px, py] = parentKey.split(',').map(Number);
                node = { x: px, y: py };
            }

            return { found: true, path };
        }

        // Explore neighbors
        for (const dir of directions) {
            const newX = current.x + dir.dx;
            const newY = current.y + dir.dy;

            // Check bounds
            if (newX < 0 || newX >= size || newY < 0 || newY >= size) continue;

            const key = `${newX},${newY}`;
            if (visited.has(key)) continue;

            // Check if cell is active (true) or is destination
            const isDestination = (newX === destinationPos.x && newY === destinationPos.y);
            const isActive = grid[newY][newX];

            if (isActive || isDestination) {
                visited.add(key);
                parent.set(key, `${current.x},${current.y}`);
                queue.push({ x: newX, y: newY });
            }
        }
    }

    return { found: false, path: [] };
}

// Check for branching in the path
function checkForBranching(path) {
    const pathSet = new Set(path.map(p => `${p.x},${p.y}`));

    // Check each true cell
    const size = currentDifficulty.gridSize;
    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            if (!grid[y][x]) continue; // Skip false cells

            const isInPath = pathSet.has(`${x},${y}`);
            const isSource = (x === sourcePos.x && y === sourcePos.y);
            const isDest = (x === destinationPos.x && y === destinationPos.y);

            if (isSource || isDest) continue;

            // Count active neighbors
            let activeNeighbors = 0;
            const directions = [
                { dx: 0, dy: -1 },
                { dx: 1, dy: 0 },
                { dx: 0, dy: 1 },
                { dx: -1, dy: 0 }
            ];

            for (const dir of directions) {
                const nx = x + dir.dx;
                const ny = y + dir.dy;

                if (nx < 0 || nx >= size || ny < 0 || ny >= size) continue;

                const isNSource = (nx === sourcePos.x && ny === sourcePos.y);
                const isNDest = (nx === destinationPos.x && ny === destinationPos.y);

                if (grid[ny][nx] || isNSource || isNDest) {
                    activeNeighbors++;
                }
            }

            // If more than 2 active neighbors, it's a branch point
            if (activeNeighbors > 2) {
                return true;
            }
        }
    }

    return false;
}

// Highlight stalled cells
function highlightStalledCells(path) {
    const pathSet = new Set(path.map(p => `${p.x},${p.y}`));
    const size = currentDifficulty.gridSize;

    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            if (!grid[y][x]) continue;

            const isSource = (x === sourcePos.x && y === sourcePos.y);
            const isDest = (x === destinationPos.x && y === destinationPos.y);

            if (isSource || isDest) continue;

            // Count active neighbors
            let activeNeighbors = 0;
            const directions = [
                { dx: 0, dy: -1 },
                { dx: 1, dy: 0 },
                { dx: 0, dy: 1 },
                { dx: -1, dy: 0 }
            ];

            for (const dir of directions) {
                const nx = x + dir.dx;
                const ny = y + dir.dy;

                if (nx < 0 || nx >= size || ny < 0 || ny >= size) continue;

                const isNSource = (nx === sourcePos.x && ny === sourcePos.y);
                const isNDest = (nx === destinationPos.x && ny === destinationPos.y);

                if (grid[ny][nx] || isNSource || isNDest) {
                    activeNeighbors++;
                }
            }

            if (activeNeighbors > 2) {
                const cell = binaryGrid.querySelector(`[data-x="${x}"][data-y="${y}"]`);
                if (cell) cell.classList.add('stalled');
            }
        }
    }
}

// Setup event listeners
function setupEventListeners() {
    startBtn.addEventListener('click', startGame);
    restartBtn.addEventListener('click', resetGame);
    retryBtn.addEventListener('click', resetGame);
    menuBtn.addEventListener('click', returnToMenu);
    backBtn.addEventListener('click', returnToMenu);
}

// Start game
function startGame() {
    gameRunning = true;
    startBtn.classList.add('hidden');
    startTimer();
}

// Start timer
function startTimer() {
    timerInterval = setInterval(() => {
        timeRemaining--;
        updateTimerDisplay();

        if (timeRemaining <= 0) {
            loseGame();
        }
    }, 1000);
}

// Update timer display
function updateTimerDisplay() {
    timerDisplay.textContent = timeRemaining;

    timerDisplay.classList.remove('warning', 'danger');
    if (timeRemaining <= 10) {
        timerDisplay.classList.add('danger');
    } else if (timeRemaining <= 15) {
        timerDisplay.classList.add('warning');
    }
}

// Stop timer
function stopTimer() {
    if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
    }
}

// Win game
function winGame() {
    gameRunning = false;
    stopTimer();

    setTimeout(() => {
        gameScreen.classList.remove('active');
        resultsScreen.classList.add('active');

        resultsStatus.textContent = 'EXPLOIT COMPLETE';
        resultsStatus.classList.add('success');
        resultsStatus.classList.remove('failure');
        resultsScore.textContent = `Time Remaining: ${timeRemaining}s`;
        resultsMessage.textContent = 'VALID CIRCUIT PATH ESTABLISHED. BINARY EXPLOIT SUCCESSFUL. SYSTEM ACCESS GRANTED.';
    }, 500);
}

// Lose game
function loseGame() {
    gameRunning = false;
    stopTimer();

    gameScreen.classList.remove('active');
    resultsScreen.classList.add('active');

    resultsStatus.textContent = 'EXPLOIT FAILED';
    resultsStatus.classList.remove('success');
    resultsStatus.classList.add('failure');
    resultsScore.textContent = 'Time Expired';
    resultsMessage.textContent = 'UNABLE TO ESTABLISH VALID CIRCUIT PATH. BINARY EXPLOIT TERMINATED. ACCESS DENIED.';
}

// Reset game
function resetGame() {
    stopTimer();
    gameRunning = false;

    resultsScreen.classList.remove('active');
    difficultyScreen.classList.add('active');

    startBtn.classList.remove('hidden');
    messageDisplay.innerHTML = '';
}

// Return to main menu
function returnToMenu() {
    window.location.href = 'index.html';
}

// Add random glitch effects
function addRandomGlitches() {
    setInterval(() => {
        if (Math.random() > 0.95) {
            const header = document.querySelector('.header-text');
            if (header) {
                header.style.animation = 'glitch 0.3s';
                setTimeout(() => {
                    header.style.animation = '';
                }, 300);
            }
        }
    }, 2000);
}

// Add glitch animation
const style = document.createElement('style');
style.textContent = `
    @keyframes glitch {
        0%, 100% { transform: translate(0); }
        25% { transform: translate(-2px, 2px); }
        50% { transform: translate(2px, -2px); }
        75% { transform: translate(-2px, -2px); }
    }
`;
document.head.appendChild(style);

// Initialize on page load
document.addEventListener('DOMContentLoaded', async function() {
    // Load and start ambient sound
    await loadAmbientSound();
    startAmbientSound();

    init();
    addRandomGlitches();
});
